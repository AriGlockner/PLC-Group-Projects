#lang racket

(provide (all-defined-out))

(require "utils.rkt")

; (<op> <int exp> <int exp>) OR (<op> <int exp>)
(define (M_int ls state return)
  (cond
    ((number? ls)
     (return ls))
    ((atom? ls)
     (return (lookup ls state)))
    ((and (eq? (operator ls) '-) (null? (rightside ls)))
     (* (M_int (leftoperand ls) state return) -1))
    ((eq? (operator ls) '+) (+ (M_int (leftoperand ls) state return)
                               (return (M_int (rightoperand ls) state return))))
    ((eq? (operator ls) '-) (- (M_int (leftoperand ls) state return)
                               (return (M_int (rightoperand ls) state return))))
    ((eq? (operator ls) '*) (* (M_int (leftoperand ls) state return)
                               (return (M_int (rightoperand ls) state return))))
    ((eq? (operator ls) '/) (quotient (M_int (leftoperand ls) state return)
                                      (return (M_int (rightoperand ls) state return))))
    ((eq? (operator ls) '%) (remainder (M_int (leftoperand ls) state return)
                                       (return (M_int (rightoperand ls) state return))))
    (else                   (return 'error))))


;(<op> <bool exp> <bool exp>) OR (<op> <bool exp>)
(define (M_bool ls state return)
  (cond
    ; base cases
    ((eq? 'true ls)
     (return 'true))
    ((eq? 'false ls)
     (return 'false))
    ((atom? ls)
     (return (lookup ls state)))
    ; if we're dealing with the unary operator and the expression is...
    ((and (and (eq? (operator ls) '!) (null? (rightside ls)))
          (eq? (M_bool (leftoperand ls) state return)
               (return 'true)))
     'false) ; ...true, then return false
    ((and (and (eq? (operator ls) '!)
               (null? (rightside ls)))
          (eq? (M_bool (leftoperand ls) state return)
               'false))
     (return 'true)) ; ...false, then return true
    ; Can't just compare #t and #f, because we need to return 'true and 'false
    ; That means we need to check all cases for each operator that could return 'true or 'false
    ((and (eq? (operator ls) '&&)
          (and (eq? (M_bool (leftoperand ls) state return)
                    'true)
               (eq? (M_bool (rightoperand ls) state return) 'true)))
     (return 'true))
    ((and (eq? (operator ls) '&&)
          (or (eq? (M_bool (leftoperand ls) state return)
                   'false)
              (eq? (M_bool (rightoperand ls) state return) 'false)))
     (return 'false))
    ((and (eq? (operator ls) '||) (eq? (M_bool (leftoperand ls) state return) 'true))
                                                                (return 'true))
    ((and (eq? (operator ls) '||) (eq? (M_bool (rightoperand ls) state return) 'true))
                                                                (return 'true))
    ((and (eq? (operator ls) '||) (and (eq? (M_bool (rightoperand ls) state return) 'false)
                                       (eq? (M_bool (leftoperand ls) state return) 'false))
                                                                (return 'false)))
    ((and (eq? (operator ls) '==) (eq? (M_int (rightoperand ls) state return)
                                       (M_int (leftoperand ls) state return)))
                                                                (return 'true))
    ((and (eq? (operator ls) '==) (not (eq? (M_int (rightoperand ls) state return)
                                            (M_int (leftoperand ls) state return))))
                                                                (return 'false))
    ((and (eq? (operator ls) '!=) (not (eq? (M_int (rightoperand ls) state return)
                                            (M_int (leftoperand ls) state return))))
                                                                (return 'true))
    ((and (eq? (operator ls) '!=) (eq? (M_value (rightoperand ls) state return)
                                       (M_value (leftoperand ls) state return)))
                                                                (return 'false))
    ((and (eq? (operator ls) '>) (> (M_int (leftoperand ls) state return)
                                    (M_int (rightoperand ls) state return)))
                                                                (return 'true))
    ((and (eq? (operator ls) '>) (not (> (M_int (leftoperand ls) state return)
                                         (M_int (rightoperand ls) state return))))
                                                                (return 'false))
    ((and (eq? (operator ls) '<) (< (M_int (leftoperand ls) state return)
                                    (M_int (rightoperand ls) state return)))
                                                                (return 'true))
    ((and (eq? (operator ls) '<) (not (< (M_int (leftoperand ls) state return)
                                         (M_int (rightoperand ls) state return))))
                                                                (return 'false))
    ((and (eq? (operator ls) '<=) (<= (M_int (leftoperand ls) state return)
                                      (M_int (rightoperand ls) state return)))
                                                                (return 'true))
    ((and (eq? (operator ls) '<=) (not (<= (M_int (leftoperand ls) state return)
                                           (M_int (rightoperand ls) state return))))
                                                                (return 'false))
    ((and (eq? (operator ls) '>=) (>= (M_int (leftoperand ls) state return)
                                      (M_int (rightoperand ls) state return)))
                                                                (return 'true))
    ((and (eq? (operator ls) '>=) (not (>= (M_int (leftoperand ls) state return)
                                           (M_int (rightoperand ls) state return))))
                                                                (return 'false))
    (else                                                       (return 'error))))


; Given some arbitrary expression, determine the value of the expression
(define (M_value ls state return)
  (cond
    ; first two are useful just to catch here, so we don't always have to go to M_bool
    ((eq? ls 'true)                       (return 'true))
    ((eq? ls 'false)                      (return 'false))
    ((number? ls)                         (return (M_int ls state return)))
    ; Not a simple expression, try getting a value from M_int or M_bool
    ((not (eq? (M_int ls state return) 'error))  (return (M_int ls state return)))
    ((not (eq? (M_bool ls state return) 'error)) (return (M_bool ls state return)))
    ; For handling cases like (M_bool '((false)) state), without this line just gives error
    ((list? ls)                           (return (M_value (car ls) state return)))
    (else                                 (return 'error))))